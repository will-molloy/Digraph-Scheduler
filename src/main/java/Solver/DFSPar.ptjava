package Solver;

import java.util.Iterator;
import java.util.Set;
import java.util.stream.IntStream;

import CommonInterface.ISearchState;
import Graph.EdgeWithCost;
import Graph.Vertex;
import Graph.Graph;

import lombok.Data;
import pt.runtime.CurrentTask;
import pt.runtime.ParaTask;
import pt.runtime.TaskID;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;

public class DFSPar extends DFSolver{
	
	/**
	 * @author kzy0618
	 * DFS B&B parallel solving class.
	 * DFSPar can set size of the thread pool and it is thread safe
	 */
	public DFSPar(Graph<Vertex, EdgeWithCost<Vertex>> graph, int processorCount, int parNumber) {
		super(graph, processorCount,parNumber);
	}


	@Override
	public void doSolve() {
		SearchState.initialise(graph,processorCount);
		SearchState nullstate = new SearchState();
		calculatingnNextLayerSearchingState(nullstate);
		currBestState = parallelTask.peek();
		setTimer();
		
		ParaTask.setScheduling(ParaTask.ScheduleType.WorkSharing);
		TaskIDGroup solvingGroup = this.buildTask(parallelTask);
		try {
			solvingGroup.waitTillFinished();
		} catch (Exception e) {
			e.printStackTrace();
		}
		updateTime();
		scheduleVertices();
	}
	
	/**
	 * @author kzy0618
	 * Run solving state on different searchstate in separate thread 
	 * @Param ConcurrentLinkedQueue<SearchState>
	 */
	TASK(*) public void buildTask(ConcurrentLinkedQueue<SearchState> states) {
		SearchState currentState = null;
		while((currentState = states.poll()) != null) {
	        long id = Thread.currentThread().getId();
			solving(currentState);
		}
	}
	
	
	
	
}